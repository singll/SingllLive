# é…·ç‹—éŸ³ä¹é›†æˆæ–¹æ¡ˆï¼šæ­Œè¯æ˜¾ç¤ºä¸ç‚¹æ­Œ

> **æ–¹æ¡ˆå¯¹æ¯”ä¸å¯è¡Œæ€§åˆ†æ** - VLC vs é…·ç‹—éŸ³ä¹çš„é›†æˆæ–¹æ³•

---

## ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”

### å½“å‰æ–¹æ¡ˆï¼ˆVLCï¼‰
- âœ… å¼€æºã€ç¨³å®šã€æ˜“æ§åˆ¶
- âœ… Plan A æ–‡ä»¶ç³»ç»Ÿæ§åˆ¶æˆç†Ÿ
- âŒ æ²¡æœ‰åŸç”Ÿæ­Œè¯æ˜¾ç¤ºèƒ½åŠ›
- âŒ éœ€è¦æ‰‹åŠ¨è·å–æ­Œè¯ï¼ˆå›°éš¾ï¼‰
- âœ… å¯å®Œå…¨è‡ªå®šä¹‰åŒ–

### é…·ç‹—éŸ³ä¹æ–¹æ¡ˆ
- âœ… ä¸°å¯Œçš„æ­Œè¯åº“
- âœ… å¼€æ”¾çš„ API æ¥å£
- âœ… å®˜æ–¹ç‚¹æ­ŒåŠŸèƒ½
- âŒ å¯æ§æ€§ä¸å¦‚ VLC
- âŒ å¯èƒ½å­˜åœ¨ç‰ˆæƒé™åˆ¶

---

## ğŸ¯ æ¨èæ–¹æ¡ˆï¼šæ··åˆæ¶æ„

ä¸å»ºè®®å®Œå…¨æ›¿æ¢ VLCï¼Œè€Œæ˜¯é‡‡ç”¨ **æ··åˆæ–¹æ¡ˆ**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           SingllLive æ··åˆéŸ³ä¹ç³»ç»Ÿæ¶æ„                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  â‘  éŸ³ä¹æ’­æ”¾å±‚ (åŒè½¨åˆ¶)                                    â”‚
â”‚  â”œâ”€ VLC (ç»§ç»­ç”¨äºæœ¬åœ°æ–‡ä»¶æ’­æ”¾)                           â”‚
â”‚  â”‚  â””â”€ è½®æ’­æ¨¡å¼ï¼šæ’­æ”¾ songs/playback ä¸­çš„ mp3            â”‚
â”‚  â”‚                                                      â”‚
â”‚  â””â”€ é…·ç‹— API (ç‚¹æ­Œå’Œæ­Œè¯è·å–)                            â”‚
â”‚     â””â”€ ç‚¹æ­Œæ¨¡å¼ï¼šé€šè¿‡é…·ç‹— API æœç´¢å’Œè·å–æ­Œæ›²              â”‚
â”‚                                                      â”‚
â”‚  â‘¡ æ­Œè¯å±‚ (ç»Ÿä¸€ç”±é…·ç‹—æä¾›)                                â”‚
â”‚  â””â”€ ä»é…·ç‹— API è·å–æ­Œè¯                                  â”‚
â”‚     â”œâ”€ æ˜¾ç¤ºåˆ° OBS (lyrics_display)                      â”‚
â”‚     â””â”€ æ”¯æŒå®æ—¶æ»šåŠ¨/æ­Œè¯åŒæ­¥                             â”‚
â”‚                                                      â”‚
â”‚  â‘¢ ç‚¹æ­Œå±‚ (å®Œå…¨ä»é…·ç‹—è¿ç§»)                                â”‚
â”‚  â”œâ”€ é€šè¿‡å¼¹å¹•/ç½‘é¡µè°ƒç”¨é…·ç‹—æœç´¢                            â”‚
â”‚  â”œâ”€ è·å–æ­Œæ›²ä¿¡æ¯å’Œæ’­æ”¾é“¾æ¥                              â”‚
â”‚  â””â”€ æ— ç¼æ•´åˆåˆ°ç°æœ‰ç³»ç»Ÿ                                  â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”Œ å®ç°æ–¹æ¡ˆ Aï¼šPython é›†æˆæ–¹æ¡ˆ (æ¨è)

### æ–¹æ¡ˆè¯´æ˜
- ä½¿ç”¨ Python è°ƒç”¨é…·ç‹— API
- ä¿ç•™ VLC ç”¨äºæœ¬åœ°æ–‡ä»¶æ’­æ”¾
- ç‚¹æ­Œæ—¶é€šè¿‡ API è·å–æ­Œæ›²
- æ­Œè¯ç”± Python åç«¯è·å–å¹¶æ˜¾ç¤ºåˆ° OBS

### æ ¸å¿ƒæ¨¡å—æ¶æ„

```python
# modules/kugou_api.py (æ–°å¢)
class KugouAPI:
    """é…·ç‹—éŸ³ä¹ API å®¢æˆ·ç«¯"""

    async def search_song(self, keywords: str) -> list:
        """æœç´¢æ­Œæ›²

        Args:
            keywords: æœç´¢å…³é”®è¯

        Returns:
            [
                {
                    'id': 'æ­Œæ›²ID',
                    'name': 'æ­Œæ›²å',
                    'artist': 'è‰ºæœ¯å®¶',
                    'lyrics_url': 'æ­Œè¯é“¾æ¥'
                },
                ...
            ]
        """

    async def get_lyrics(self, song_id: str) -> dict:
        """è·å–æ­Œè¯

        Args:
            song_id: é…·ç‹—æ­Œæ›² ID

        Returns:
            {
                'song_name': 'æ­Œæ›²å',
                'artist': 'è‰ºæœ¯å®¶',
                'content': 'æ­Œè¯å†…å®¹ (LRC æ ¼å¼)',
                'lines': [
                    {'time': '00:10', 'text': 'æ­Œè¯è¡Œ'},
                    ...
                ]
            }
        """

    async def get_download_url(self, song_id: str) -> str:
        """è·å–æ­Œæ›²ä¸‹è½½é“¾æ¥

        ç”¨äºæœ¬åœ°æ’­æ”¾æˆ–æµåª’ä½“
        """

# modules/lyrics_display.py (æ–°å¢)
class LyricsDisplay:
    """æ­Œè¯æ˜¾ç¤ºç®¡ç†"""

    def __init__(self, output_path: str):
        """åˆå§‹åŒ–

        Args:
            output_path: è¾“å‡ºå›¾åƒè·¯å¾„ (ä¾› OBS æ˜¾ç¤º)
        """

    async def render_lyrics(self, song_info: dict, current_time: float) -> str:
        """æ¸²æŸ“æ­Œè¯å›¾åƒ

        Args:
            song_info: æ­Œæ›²ä¿¡æ¯å’Œæ­Œè¯
            current_time: å½“å‰æ’­æ”¾æ—¶é—´ (ç§’)

        Returns:
            è¾“å‡ºå›¾åƒè·¯å¾„

        åŠŸèƒ½:
        - æ ¹æ®æ—¶é—´æ˜¾ç¤ºå¯¹åº”æ­Œè¯è¡Œ
        - çªå‡ºæ˜¾ç¤ºå½“å‰æ¼”å”±çš„æ­Œè¯
        - æ˜¾ç¤ºæ­Œæ›²åå’Œè‰ºæœ¯å®¶
        - ä¼˜é›…çš„æ’ç‰ˆå’ŒåŠ¨ç”»
        """

# cyber_live.py (ä¿®æ”¹)
async def _lyrics_sync_loop(lyrics_display, vlc, kugou_api):
    """æ­Œè¯åŒæ­¥å¾ªç¯

    å®šæœŸ:
    1. è·å–å½“å‰æ’­æ”¾æ—¶é—´ (ä» VLC æˆ–é…·ç‹—)
    2. ä»ç¼“å­˜è·å–å½“å‰æ­Œæ›²æ­Œè¯
    3. è°ƒç”¨ lyrics_display.render_lyrics() ç”Ÿæˆå›¾åƒ
    4. OBS è‡ªåŠ¨åˆ·æ–°æ˜¾ç¤º
    """
```

### ä¼˜åŠ¿
âœ… ä¿ç•™ VLC çš„ç¨³å®šæ€§å’Œæœ¬åœ°æ’­æ”¾èƒ½åŠ›
âœ… å……åˆ†åˆ©ç”¨é…·ç‹—çš„æ­Œè¯åº“
âœ… ç‚¹æ­ŒåŠŸèƒ½åŸç”Ÿæ”¯æŒ
âœ… æ­Œè¯æ˜¾ç¤ºå®æ—¶åŒæ­¥
âœ… ä»£ç æ”¹åŠ¨æœ€å°åŒ–

### åŠ£åŠ¿
âŒ éœ€è¦å¤„ç† API è°ƒç”¨å»¶è¿Ÿ
âŒ ä¾èµ–é…·ç‹— API å¯ç”¨æ€§
âŒ å¯èƒ½å­˜åœ¨ç‰ˆæƒé™åˆ¶

---

## ğŸ”Œ å®ç°æ–¹æ¡ˆ Bï¼šå®Œå…¨æ›¿æ¢ VLC (ä¸æ¨è)

### æ–¹æ¡ˆè¯´æ˜
- å®Œå…¨ç”¨é…·ç‹—éŸ³ä¹æ›¿ä»£ VLC
- æ‰€æœ‰æ’­æ”¾éƒ½é€šè¿‡é…·ç‹—
- å®Œæ•´çš„é…·ç‹—ç”Ÿæ€

### åŠ£åŠ¿ï¼ˆè¿™æ˜¯ä¸ºä»€ä¹ˆä¸æ¨èï¼‰
âŒ é…·ç‹— API ç¨³å®šæ€§å’Œç‰ˆæƒé™åˆ¶æœªçŸ¥
âŒ å®Œå…¨é‡æ„ Plan A æ’­æ”¾ç³»ç»Ÿ
âŒ å¤±å»å¯¹æœ¬åœ°æ–‡ä»¶çš„æ§åˆ¶
âŒ å¦‚æœ API å¤±æ•ˆï¼Œæ•´ä¸ªç³»ç»Ÿç˜«ç—ª
âŒ ç‚¹æ­ŒåŠŸèƒ½å¼ºä¾èµ–é…·ç‹—

---

## âœ… æ¨èæ–¹æ¡ˆè¯¦ç»†å®ç°

### ç¬¬ä¸€æ­¥ï¼šlyrics_display æºé…ç½® (OBS)

**é…ç½®æ­¥éª¤ï¼š**

1. **åœ¨ AScreen ä¸­ä¿®æ”¹ lyrics_display æº**
   ```
   OBS â†’ AScreen â†’ æºé¢æ¿
   åŒå‡» lyrics_display æº â†’ å±æ€§

   è®¾ç½®ä¸º "å›¾åƒ" æˆ– "å›¾åƒå¹»ç¯ç‰‡"
   é€‰æ‹©æ–‡ä»¶: data/current_lyrics.png
   ```

2. **é…ç½®è‡ªåŠ¨åˆ·æ–°**
   ```lua
   -- scripts/obs/lyrics_refresh.lua (ç±»ä¼¼ panel_refresh.lua)

   local function on_event(event)
       if event == obs.OBS_FRONTEND_EVENT_SCRIPTING_SHUTDOWN then
           return
       end

       -- æ¯ 100ms åˆ·æ–°ä¸€æ¬¡ lyrics æº
       -- ä» data/current_lyrics.png è¯»å–æœ€æ–°çš„æ­Œè¯å›¾åƒ
       obs.obs_source_list_release(sources)
   end
   ```

### ç¬¬äºŒæ­¥ï¼šé›†æˆé…·ç‹— API

**å®‰è£…ä¾èµ–ï¼š**

```bash
pip install kugou-api  # æˆ–ä½¿ç”¨å…¶ä»–é…·ç‹— API åº“
# æˆ–æ‰‹åŠ¨å®ç° HTTP è¯·æ±‚è°ƒç”¨é…·ç‹— API
```

**å®ç° modules/kugou_api.pyï¼š**

```python
import aiohttp
import logging
from typing import Optional, List, Dict

log = logging.getLogger("kugou")

class KugouAPI:
    """é…·ç‹—éŸ³ä¹ API å®¢æˆ·ç«¯"""

    BASE_URL = "http://searpc.kugou.com/v1/search/songs"
    LYRICS_URL = "http://lyrics.kugou.com/download"

    def __init__(self, timeout: int = 10):
        self.timeout = timeout
        self.session: Optional[aiohttp.ClientSession] = None

    async def _get_session(self) -> aiohttp.ClientSession:
        """è·å– HTTP ä¼šè¯"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        return self.session

    async def search_song(self, keywords: str, page: int = 1) -> List[Dict]:
        """æœç´¢æ­Œæ›²

        Args:
            keywords: æœç´¢å…³é”®è¯
            page: é¡µç  (é»˜è®¤ 1)

        Returns:
            æ­Œæ›²åˆ—è¡¨
        """
        try:
            session = await self._get_session()

            params = {
                'keyword': keywords,
                'page': page,
                'pagesize': 10,
                'bitrate': 0
            }

            async with session.get(
                self.BASE_URL,
                params=params,
                timeout=self.timeout
            ) as resp:
                if resp.status != 200:
                    log.error(f"æœç´¢å¤±è´¥: {resp.status}")
                    return []

                data = await resp.json()
                songs = []

                for item in data.get('data', {}).get('songs', []):
                    song = {
                        'id': item.get('ID'),
                        'name': item.get('SongName'),
                        'artist': ', '.join([
                            a.get('ArtistName', '')
                            for a in item.get('ArtistArray', [])
                        ]),
                        'album': item.get('AlbumName'),
                        'duration': item.get('Duration', 0),
                        'hash': item.get('FileHash'),
                    }
                    songs.append(song)

                log.info(f"æœç´¢ '{keywords}' æ‰¾åˆ° {len(songs)} é¦–æ­Œæ›²")
                return songs

        except Exception as e:
            log.error(f"æœç´¢æ­Œæ›²å¼‚å¸¸: {e}")
            return []

    async def get_lyrics(self, song_hash: str, song_id: str) -> Optional[Dict]:
        """è·å–æ­Œè¯

        Args:
            song_hash: æ­Œæ›² hash
            song_id: æ­Œæ›² ID

        Returns:
            æ­Œè¯ä¿¡æ¯æˆ– None
        """
        try:
            session = await self._get_session()

            params = {
                'hash': song_hash,
                'id': song_id,
                'client': 'pc',
                'ft': '0'
            }

            async with session.get(
                self.LYRICS_URL,
                params=params,
                timeout=self.timeout
            ) as resp:
                if resp.status != 200:
                    return None

                text = await resp.text()

                # è§£æ LRC æ ¼å¼æ­Œè¯
                lines = self._parse_lrc(text)

                return {
                    'content': text,
                    'lines': lines,
                }

        except Exception as e:
            log.error(f"è·å–æ­Œè¯å¼‚å¸¸: {e}")
            return None

    @staticmethod
    def _parse_lrc(lrc_content: str) -> List[Dict]:
        """è§£æ LRC æ­Œè¯æ ¼å¼

        LRC æ ¼å¼:
        [00:10.00]ç¬¬ä¸€è¡Œæ­Œè¯
        [00:20.00]ç¬¬äºŒè¡Œæ­Œè¯

        Returns:
            [
                {'time': 10.0, 'text': 'ç¬¬ä¸€è¡Œæ­Œè¯'},
                {'time': 20.0, 'text': 'ç¬¬äºŒè¡Œæ­Œè¯'},
                ...
            ]
        """
        lines = []
        for line in lrc_content.split('\n'):
            line = line.strip()
            if line.startswith('[') and ']' in line:
                try:
                    time_str = line[1:line.index(']')]
                    text = line[line.index(']') + 1:]

                    # è½¬æ¢æ—¶é—´æ ¼å¼ mm:ss.cc -> ç§’
                    parts = time_str.split(':')
                    minutes = int(parts[0])
                    seconds = float(parts[1])
                    total_seconds = minutes * 60 + seconds

                    lines.append({
                        'time': total_seconds,
                        'text': text
                    })
                except (ValueError, IndexError):
                    continue

        return lines

    async def close(self):
        """å…³é—­ä¼šè¯"""
        if self.session:
            await self.session.close()
```

### ç¬¬ä¸‰æ­¥ï¼šå®ç°æ­Œè¯æ˜¾ç¤º

```python
# modules/lyrics_display.py (æ–°å¢)

from PIL import Image, ImageDraw, ImageFont
import os
from typing import Dict, List
import logging

log = logging.getLogger("lyrics")

class LyricsDisplay:
    """æ­Œè¯æ˜¾ç¤ºæ¸²æŸ“"""

    def __init__(self, output_path: str = "data/current_lyrics.png"):
        self.output_path = output_path
        # æ ‡å‡†åˆ†è¾¨ç‡ï¼ˆä¸ OBS ä¸­ lyrics_display æºå¤§å°ä¸€è‡´ï¼‰
        self.width = 1344
        self.height = 756
        self.bg_color = (0, 0, 0)  # é»‘è‰²èƒŒæ™¯
        self.text_color = (255, 255, 255)  # ç™½è‰²æ–‡å­—
        self.current_color = (0, 255, 0)  # ç»¿è‰²å½“å‰è¡Œ

    async def render_lyrics(
        self,
        song_info: Dict,
        current_time: float = 0
    ) -> str:
        """æ¸²æŸ“æ­Œè¯å¹¶ä¿å­˜ä¸ºå›¾åƒ

        Args:
            song_info: {
                'name': 'æ­Œæ›²å',
                'artist': 'è‰ºæœ¯å®¶',
                'lyrics': [
                    {'time': 10.0, 'text': 'æ­Œè¯è¡Œ'},
                    ...
                ]
            }
            current_time: å½“å‰æ’­æ”¾æ—¶é—´ (ç§’)

        Returns:
            è¾“å‡ºå›¾åƒè·¯å¾„
        """
        try:
            # åˆ›å»ºèƒŒæ™¯å›¾åƒ
            img = Image.new('RGB', (self.width, self.height), self.bg_color)
            draw = ImageDraw.Draw(img)

            # åŠ è½½å­—ä½“ (ä½¿ç”¨ç³»ç»Ÿå­—ä½“)
            try:
                # Windows
                font = ImageFont.truetype("C:\\Windows\\Fonts\\msyh.ttc", 40)
                small_font = ImageFont.truetype("C:\\Windows\\Fonts\\msyh.ttc", 24)
            except:
                try:
                    # Linux
                    font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 40)
                    small_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 24)
                except:
                    # Fallback
                    font = ImageFont.load_default()
                    small_font = font

            # ç»˜åˆ¶æ­Œæ›²ä¿¡æ¯
            draw.text(
                (672, 50),
                f"{song_info.get('name', 'æœªçŸ¥æ­Œæ›²')} - {song_info.get('artist', 'æœªçŸ¥è‰ºæœ¯å®¶')}",
                fill=self.text_color,
                font=font,
                anchor="mm"
            )

            # ç»˜åˆ¶æ­Œè¯
            lyrics = song_info.get('lyrics', [])
            if not lyrics:
                # å¦‚æœæ²¡æœ‰æ­Œè¯ï¼Œæ˜¾ç¤ºæç¤º
                draw.text(
                    (672, 400),
                    "æš‚æ— æ­Œè¯",
                    fill=self.text_color,
                    font=font,
                    anchor="mm"
                )
            else:
                # æ‰¾åˆ°å½“å‰å’Œå‰åå‡ è¡Œæ­Œè¯
                current_idx = -1
                for i, line in enumerate(lyrics):
                    if line['time'] > current_time:
                        current_idx = i - 1
                        break
                else:
                    current_idx = len(lyrics) - 1

                # æ˜¾ç¤ºå‰ 3 è¡Œã€å½“å‰è¡Œã€å 3 è¡Œ
                start_idx = max(0, current_idx - 3)
                end_idx = min(len(lyrics), current_idx + 4)

                y_pos = 200
                for i in range(start_idx, end_idx):
                    line = lyrics[i]
                    text = line['text']
                    color = self.current_color if i == current_idx else self.text_color

                    draw.text(
                        (672, y_pos),
                        text,
                        fill=color,
                        font=font if i == current_idx else small_font,
                        anchor="mm"
                    )
                    y_pos += 80

            # ä¿å­˜å›¾åƒ
            os.makedirs(os.path.dirname(self.output_path), exist_ok=True)
            img.save(self.output_path)

            log.debug(f"æ­Œè¯å·²æ¸²æŸ“: {self.output_path}")
            return self.output_path

        except Exception as e:
            log.error(f"æ¸²æŸ“æ­Œè¯å¤±è´¥: {e}")
            return self.output_path
```

### ç¬¬å››æ­¥ï¼šé›†æˆåˆ°ä¸»ç¨‹åº

```python
# cyber_live.py (ä¿®æ”¹)

async def _lyrics_sync_loop(
    lyrics_display: LyricsDisplay,
    current_song_info: Dict,
    interval: float = 0.5
):
    """æ­Œè¯åŒæ­¥å¾ªç¯

    å®šæœŸåˆ·æ–°æ­Œè¯æ˜¾ç¤ºï¼Œä¿æŒä¸æ’­æ”¾åŒæ­¥
    """
    log.info("æ­Œè¯åŒæ­¥å¾ªç¯å¯åŠ¨")
    last_rendered_time = -1

    try:
        while True:
            try:
                # è·å–å½“å‰æ’­æ”¾æ—¶é—´
                # æ–¹å¼ 1: ä» VLC è·å–
                # current_time = await vlc.get_current_time()

                # æ–¹å¼ 2: ä»æ–‡ä»¶è¯»å– (å¦‚æœæœ‰æ—¶é—´æˆ³)
                # current_time = load_playback_time()

                # ä¸ºäº†æ¼”ç¤ºï¼Œè¿™é‡Œå›ºå®šè·å–æ—¶é—´
                # å®é™…éœ€è¦ä¸ VLC æˆ–æ’­æ”¾å™¨åŒæ­¥
                current_time = get_current_playback_time()

                # é¿å…é¢‘ç¹é‡æ–°æ¸²æŸ“
                if abs(current_time - last_rendered_time) > 0.1:
                    await lyrics_display.render_lyrics(
                        current_song_info,
                        current_time
                    )
                    last_rendered_time = current_time

            except Exception as e:
                log.debug(f"æ­Œè¯åŒæ­¥å¼‚å¸¸: {e}")

            await asyncio.sleep(interval)

    except asyncio.CancelledError:
        log.info("æ­Œè¯åŒæ­¥å¾ªç¯å·²å–æ¶ˆ")
```

---

## ğŸ“‹ ç‚¹æ­Œé›†æˆæ–¹æ¡ˆ

### æ–¹æ¡ˆ 1ï¼šç›´æ¥é€šè¿‡é…·ç‹— API ç‚¹æ­Œ (æ¨è)

```python
# modules/danmaku.py (ä¿®æ”¹ç‚¹æ­Œå¤„ç†)

async def handle_request_song(self, user: str, song_name: str):
    """å¤„ç†ç‚¹æ­Œå‘½ä»¤

    ç”¨æˆ·å¼¹å¹•: "ç‚¹æ­Œ æ­Œå"
    """
    log.info(f"{user} ç‚¹æ­Œ: {song_name}")

    # 1. é€šè¿‡é…·ç‹— API æœç´¢æ­Œæ›²
    results = await self.kugou_api.search_song(song_name)

    if not results:
        self.send_message(f"@{user} æœªæ‰¾åˆ°æ­Œæ›² '{song_name}'")
        return

    # 2. é€‰æ‹©ç¬¬ä¸€ä¸ªç»“æœ
    song = results[0]
    log.info(f"æ‰¾åˆ°æ­Œæ›²: {song['name']} - {song['artist']}")

    # 3. è·å–æ­Œè¯
    lyrics_info = await self.kugou_api.get_lyrics(
        song['hash'],
        song['id']
    )

    # 4. æ·»åŠ åˆ°é˜Ÿåˆ—
    queue_entry = {
        'id': song['id'],
        'name': song['name'],
        'artist': song['artist'],
        'duration': song['duration'],
        'user': user,
        'lyrics': lyrics_info,
        'url': f"http://www.kugou.com/song/{song['id']}.html"
    }

    self.songs.queue.append(queue_entry)
    self.send_message(f"@{user} å·²æ·»åŠ åˆ°é˜Ÿåˆ—: {song['name']}")

    # 5. æ›´æ–°ç‚¹æ­Œé˜Ÿåˆ—æ˜¾ç¤º (BScreen)
    await self.update_song_queue_display()
```

### æ–¹æ¡ˆ 2ï¼šç½‘é¡µç‚¹æ­Œç•Œé¢

```html
<!-- web/request_song.html -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ç‚¹æ­Œ</title>
    <style>
        body { font-family: å¾®è½¯é›…é»‘; }
        #search-results { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .song-item { padding: 10px; border: 1px solid #ccc; cursor: pointer; }
        .song-item:hover { background: #f0f0f0; }
    </style>
</head>
<body>
    <h1>ç‚¹æ­Œç³»ç»Ÿ</h1>
    <input id="search-box" type="text" placeholder="è¾“å…¥æ­Œæ›²åæˆ–è‰ºæœ¯å®¶" />
    <button onclick="search()">æœç´¢</button>

    <div id="search-results"></div>

    <script>
        async function search() {
            const keyword = document.getElementById('search-box').value;
            const response = await fetch(`/api/search_song?q=${keyword}`);
            const results = await response.json();

            const html = results.map(song => `
                <div class="song-item" onclick="requestSong('${song.id}', '${song.name}')">
                    <strong>${song.name}</strong><br>
                    ${song.artist}
                </div>
            `).join('');

            document.getElementById('search-results').innerHTML = html;
        }

        async function requestSong(id, name) {
            await fetch('/api/request_song', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ song_id: id })
            });
            alert(`å·²æ·»åŠ : ${name}`);
        }
    </script>
</body>
</html>
```

---

## ğŸ¬ lyrics_display æ˜¾ç¤ºæ–¹æ¡ˆå¯¹æ¯”

### æ–¹æ¡ˆ Aï¼šçº¯æ–‡å­—æ˜¾ç¤º (ç®€å•)
```
æ­Œæ›²: ã€Šä¸‰ä½“ã€‹- è®¸åµ©

å‰ä¸€è¡Œæ­Œè¯
å½“å‰è¡Œæ­Œè¯ (é«˜äº®)
åä¸€è¡Œæ­Œè¯
```

### æ–¹æ¡ˆ Bï¼šå½©è‰²æ¸è¿›å¼ (ä¼˜é›…)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸‰ä½“ - è®¸åµ©                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                              â”‚
â”‚      å·²å”±è¿‡çš„æ­Œè¯ (ç°è‰²)       â”‚
â”‚      å½“å‰è¡Œæ­Œè¯ (ç»¿è‰²)         â”‚
â”‚      å¾…å”±çš„æ­Œè¯ (ç™½è‰²)         â”‚
â”‚                              â”‚
â”‚      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  â”‚
â”‚      1:23 / 3:45            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ–¹æ¡ˆ Cï¼šå®æ—¶æ»šåŠ¨ (ç‚«å½©)
- æ­Œè¯é€å­—æ˜¾ç¤º
- å½“å‰å­—é«˜äº®æˆ–å˜è‰²
- è‡ªåŠ¨æ»šåŠ¨æ•ˆæœ

---

## ğŸš€ å®ç°æ­¥éª¤

### Step 1: å®‰è£…é…·ç‹— API åº“
```bash
pip install aiohttp  # é…·ç‹— API é€šè¿‡ HTTP è°ƒç”¨
```

### Step 2: å®ç°é…·ç‹— API æ¨¡å—
- åˆ›å»º `modules/kugou_api.py`
- å®ç°æœç´¢ã€è·å–æ­Œè¯ã€è·å–ä¸‹è½½é“¾æ¥

### Step 3: å®ç°æ­Œè¯æ˜¾ç¤ºæ¨¡å—
- åˆ›å»º `modules/lyrics_display.py`
- ä½¿ç”¨ PIL æ¸²æŸ“æ­Œè¯å›¾åƒ

### Step 4: ä¿®æ”¹ç‚¹æ­Œé€»è¾‘
- æ›´æ–° `modules/danmaku.py` çš„ç‚¹æ­Œå¤„ç†
- è°ƒç”¨é…·ç‹— API æœç´¢æ­Œæ›²

### Step 5: é›†æˆæ­Œè¯åŒæ­¥
- åœ¨ `cyber_live.py` æ·»åŠ æ­Œè¯åŒæ­¥å¾ªç¯
- å®šæœŸæ›´æ–° `data/current_lyrics.png`

### Step 6: OBS é…ç½®
- ä¿®æ”¹ `lyrics_display` æºä¸ºå›¾åƒ
- æŒ‡å‘ `data/current_lyrics.png`
- é…ç½®è‡ªåŠ¨åˆ·æ–°è„šæœ¬

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. ç‰ˆæƒé—®é¢˜
- âš ï¸ æ­Œæ›²å’Œæ­Œè¯å¯èƒ½å—ç‰ˆæƒä¿æŠ¤
- âš ï¸ ç›´æ’­æ—¶å¯èƒ½æ¶‰åŠç‰ˆæƒå£°æ˜
- âœ… å»ºè®®: ä»…ç”¨äºä¸ªäºº/éå•†ä¸šç›´æ’­

### 2. API ç¨³å®šæ€§
- âš ï¸ ç¬¬ä¸‰æ–¹ API å¯èƒ½å˜åŒ–æˆ–å¤±æ•ˆ
- âœ… å»ºè®®: æ·»åŠ é”™è¯¯å¤„ç†å’Œ fallback

### 3. ç½‘ç»œå»¶è¿Ÿ
- âš ï¸ æœç´¢å’Œè·å–æ­Œè¯å¯èƒ½æœ‰å»¶è¿Ÿ
- âœ… å»ºè®®: æ·»åŠ ç¼“å­˜æœºåˆ¶

### 4. æœ¬åœ°æ–‡ä»¶å¤„ç†
- âš ï¸ å¦‚ä½•å¤„ç†ç”¨æˆ·ä¸Šä¼ çš„æœ¬åœ°æ­Œæ›²?
- âœ… å»ºè®®: ä½¿ç”¨ python-lyrics åº“æŸ¥è¯¢æœ¬åœ°æ­Œæ›²æ­Œè¯

---

## ğŸ“š å‚è€ƒèµ„æº

### é…·ç‹— API æ–‡æ¡£
- [é…·ç‹—éŸ³ä¹æœç´¢ API](http://search.kugou.com/)
- [é…·ç‹—æ­Œè¯ä¸‹è½½](http://lyrics.kugou.com/)

### Python ç›¸å…³åº“
- [aiohttp](https://docs.aiohttp.org/) - å¼‚æ­¥ HTTP å®¢æˆ·ç«¯
- [Pillow (PIL)](https://python-pillow.org/) - å›¾åƒå¤„ç†
- [python-lyrics](https://github.com/wzk656/python-lyrics) - æ­Œè¯æŸ¥è¯¢

### æ›¿ä»£æ–¹æ¡ˆ
- [NetEase ç½‘æ˜“äº‘éŸ³ä¹ API](https://docs.python.org/zh-cn/3/library/)
- [Genius](https://genius.com/api-clients) - è‹±æ–‡æ­Œè¯

---

## ğŸ“ æ€»ç»“

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|------|------|------|--------|
| **A: ç»§ç»­ç”¨ VLC + é…·ç‹—æ­Œè¯** | ç¨³å®šã€æœ€å°æ”¹åŠ¨ | æ­Œè¯è·å–å›°éš¾ | â­â­â­â­â­ |
| **B: æ›¿æ¢ä¸ºé…·ç‹—å®Œå…¨æ§åˆ¶** | å®Œæ•´ã€åŸç”Ÿç‚¹æ­Œ | å¯æ§æ€§å·®ã€ä¾èµ– API | â­â­ |
| **C: ç½‘æ˜“äº‘/å…¶ä»– API** | å¯èƒ½æ›´ç¨³å®š | éœ€è¦é‡æ–°å®ç° | â­â­â­ |

**æœ€ç»ˆå»ºè®®ï¼šé‡‡ç”¨æ–¹æ¡ˆ Aï¼ˆæ··åˆæ¶æ„ï¼‰**
- ä¿ç•™ VLC çš„ç¨³å®šæ’­æ”¾
- ä½¿ç”¨é…·ç‹— API è·å–æ­Œè¯å’Œç‚¹æ­Œ
- æœ€å°åŒ–ä»£ç æ”¹åŠ¨
- æœ€å¤§åŒ–ç³»ç»Ÿç¨³å®šæ€§

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æ—¥æœŸ**: 2026-02-15
**ç»´æŠ¤è€…**: SingllLive Team
